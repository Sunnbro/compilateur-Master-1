Terminals unused in grammar

   STRING
   glm
   arobasque
   chaine


Grammaire

    0 $accept: S $end

    1 S: idf accol dt_div accol dec accor pr_div accol list_inst accor accor

    2 TYPE: FLOAT
    3     | INTEGER

    4 dec: dec_var dec
    5    | dec_cst dec
    6    | def_struc dec
    7    | dec_struc dec
    8    | /* vide */

    9 dec_var: TYPE list_variables pvg
   10        | TYPE idf baro integer barf pvg

   11 list_variables: idf
   12               | idf vrg list_variables

   13 dec_cst: CONST ent pvg

   14 ent: idf egl val
   15    | idf

   16 def_struc: STRUCT accol defst accor idf pvg

   17 defst: TYPE idf pvg
   18      | TYPE idf pvg defst

   19 dec_struc: STRUCT idf decst pvg

   20 decst: idf vrg decst
   21      | idf

   22 list_inst: INST list_inst
   23          | /* vide */

   24 INST: IF_STATEMENT
   25     | Affectation
   26     | WHILE_STATEMENT
   27     | for_boucle

   28 Affectation: idf egl expressionArith pvg
   29            | idf baro integer barf egl expressionArith pvg

   30 expressionArith: expressionArith plus terme
   31                | expressionArith minus terme
   32                | terme

   33 terme: terme times facteur
   34      | terme divise facteur
   35      | facteur

   36 facteur: idf baro integer barf
   37        | idf
   38        | val
   39        | Pouvr expressionArith Pferm

   40 ExpCondition: ExpCondition or ExpCondition
   41             | ExpCondition and ExpCondition
   42             | not ExpCondition
   43             | ExpCondition G expressionArith
   44             | ExpCondition L expressionArith
   45             | ExpCondition EQ expressionArith
   46             | ExpCondition GE expressionArith
   47             | ExpCondition LE expressionArith
   48             | ExpCondition DI expressionArith
   49             | expressionArith

   50 val: flt
   51    | integer

   52 $@1: /* vide */

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm $@1 accol list_inst accor elsebloc

   54 $@2: /* vide */

   55 elsebloc: ELSE accol $@2 list_inst accor

   56 WHILE_STATEMENT: WHILE Pouvr ExpCondition Pferm accol list_inst accor

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
dt_div (258) 1
pr_div (259) 1
IF (260) 53
ELSE (261) 55
FOR (262) 57
STRUCT (263) 16 19
WHILE (264) 56
idf (265) 1 10 11 12 14 15 16 17 18 19 20 21 28 29 36 37 57
integer (266) 10 29 36 51
flt (267) 50
minus (268) 31
plus (269) 30
times (270) 33
divise (271) 34
G (272) 43
L (273) 44
EQ (274) 45
GE (275) 46
LE (276) 47
DI (277) 48
egl (278) 14 28 29
and (279) 41
or (280) 40
not (281) 42
INTEGER (282) 3
FLOAT (283) 2
CONST (284) 13
STRING (285)
glm (286)
arobasque (287)
chaine (288)
vrg (289) 12 20
pvg (290) 9 10 13 16 17 18 19 28 29
Dpoints (291) 57
Pouvr (292) 39 53 56 57
Pferm (293) 39 53 56 57
accol (294) 1 16 53 55 56 57
accor (295) 1 16 53 55 56 57
baro (296) 10 29 36
barf (297) 10 29 36


Non-terminaux, suivis des règles où ils apparaissent

$accept (43)
    à gauche: 0
S (44)
    à gauche: 1, à droite: 0
TYPE (45)
    à gauche: 2 3, à droite: 9 10 17 18
dec (46)
    à gauche: 4 5 6 7 8, à droite: 1 4 5 6 7
dec_var (47)
    à gauche: 9 10, à droite: 4
list_variables (48)
    à gauche: 11 12, à droite: 9 12
dec_cst (49)
    à gauche: 13, à droite: 5
ent (50)
    à gauche: 14 15, à droite: 13
def_struc (51)
    à gauche: 16, à droite: 6
defst (52)
    à gauche: 17 18, à droite: 16 18
dec_struc (53)
    à gauche: 19, à droite: 7
decst (54)
    à gauche: 20 21, à droite: 19 20
list_inst (55)
    à gauche: 22 23, à droite: 1 22 53 55 56 57
INST (56)
    à gauche: 24 25 26 27, à droite: 22
Affectation (57)
    à gauche: 28 29, à droite: 25
expressionArith (58)
    à gauche: 30 31 32, à droite: 28 29 30 31 39 43 44 45 46 47 48
    49 57
terme (59)
    à gauche: 33 34 35, à droite: 30 31 32 33 34
facteur (60)
    à gauche: 36 37 38 39, à droite: 33 34 35
ExpCondition (61)
    à gauche: 40 41 42 43 44 45 46 47 48 49, à droite: 40 41 42 43
    44 45 46 47 48 53 56 57
val (62)
    à gauche: 50 51, à droite: 14 38
IF_STATEMENT (63)
    à gauche: 53, à droite: 24
$@1 (64)
    à gauche: 52, à droite: 53
elsebloc (65)
    à gauche: 55, à droite: 53
$@2 (66)
    à gauche: 54, à droite: 55
WHILE_STATEMENT (67)
    à gauche: 56, à droite: 26
for_boucle (68)
    à gauche: 57, à droite: 27


état 0

    0 $accept: . S $end

    idf  décalage et aller à l'état 1

    S  aller à l'état 2


état 1

    1 S: idf . accol dt_div accol dec accor pr_div accol list_inst accor accor

    accol  décalage et aller à l'état 3


état 2

    0 $accept: S . $end

    $end  décalage et aller à l'état 4


état 3

    1 S: idf accol . dt_div accol dec accor pr_div accol list_inst accor accor

    dt_div  décalage et aller à l'état 5


état 4

    0 $accept: S $end .

    $défaut  accepter


état 5

    1 S: idf accol dt_div . accol dec accor pr_div accol list_inst accor accor

    accol  décalage et aller à l'état 6


état 6

    1 S: idf accol dt_div accol . dec accor pr_div accol list_inst accor accor

    STRUCT   décalage et aller à l'état 7
    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9
    CONST    décalage et aller à l'état 10

    $défaut  réduction par utilisation de la règle 8 (dec)

    TYPE       aller à l'état 11
    dec        aller à l'état 12
    dec_var    aller à l'état 13
    dec_cst    aller à l'état 14
    def_struc  aller à l'état 15
    dec_struc  aller à l'état 16


état 7

   16 def_struc: STRUCT . accol defst accor idf pvg
   19 dec_struc: STRUCT . idf decst pvg

    idf    décalage et aller à l'état 17
    accol  décalage et aller à l'état 18


état 8

    3 TYPE: INTEGER .

    $défaut  réduction par utilisation de la règle 3 (TYPE)


état 9

    2 TYPE: FLOAT .

    $défaut  réduction par utilisation de la règle 2 (TYPE)


état 10

   13 dec_cst: CONST . ent pvg

    idf  décalage et aller à l'état 19

    ent  aller à l'état 20


état 11

    9 dec_var: TYPE . list_variables pvg
   10        | TYPE . idf baro integer barf pvg

    idf  décalage et aller à l'état 21

    list_variables  aller à l'état 22


état 12

    1 S: idf accol dt_div accol dec . accor pr_div accol list_inst accor accor

    accor  décalage et aller à l'état 23


état 13

    4 dec: dec_var . dec

    STRUCT   décalage et aller à l'état 7
    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9
    CONST    décalage et aller à l'état 10

    $défaut  réduction par utilisation de la règle 8 (dec)

    TYPE       aller à l'état 11
    dec        aller à l'état 24
    dec_var    aller à l'état 13
    dec_cst    aller à l'état 14
    def_struc  aller à l'état 15
    dec_struc  aller à l'état 16


état 14

    5 dec: dec_cst . dec

    STRUCT   décalage et aller à l'état 7
    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9
    CONST    décalage et aller à l'état 10

    $défaut  réduction par utilisation de la règle 8 (dec)

    TYPE       aller à l'état 11
    dec        aller à l'état 25
    dec_var    aller à l'état 13
    dec_cst    aller à l'état 14
    def_struc  aller à l'état 15
    dec_struc  aller à l'état 16


état 15

    6 dec: def_struc . dec

    STRUCT   décalage et aller à l'état 7
    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9
    CONST    décalage et aller à l'état 10

    $défaut  réduction par utilisation de la règle 8 (dec)

    TYPE       aller à l'état 11
    dec        aller à l'état 26
    dec_var    aller à l'état 13
    dec_cst    aller à l'état 14
    def_struc  aller à l'état 15
    dec_struc  aller à l'état 16


état 16

    7 dec: dec_struc . dec

    STRUCT   décalage et aller à l'état 7
    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9
    CONST    décalage et aller à l'état 10

    $défaut  réduction par utilisation de la règle 8 (dec)

    TYPE       aller à l'état 11
    dec        aller à l'état 27
    dec_var    aller à l'état 13
    dec_cst    aller à l'état 14
    def_struc  aller à l'état 15
    dec_struc  aller à l'état 16


état 17

   19 dec_struc: STRUCT idf . decst pvg

    idf  décalage et aller à l'état 28

    decst  aller à l'état 29


état 18

   16 def_struc: STRUCT accol . defst accor idf pvg

    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9

    TYPE   aller à l'état 30
    defst  aller à l'état 31


état 19

   14 ent: idf . egl val
   15    | idf .

    egl  décalage et aller à l'état 32

    $défaut  réduction par utilisation de la règle 15 (ent)


état 20

   13 dec_cst: CONST ent . pvg

    pvg  décalage et aller à l'état 33


état 21

   10 dec_var: TYPE idf . baro integer barf pvg
   11 list_variables: idf .
   12               | idf . vrg list_variables

    vrg   décalage et aller à l'état 34
    baro  décalage et aller à l'état 35

    $défaut  réduction par utilisation de la règle 11 (list_variables)


état 22

    9 dec_var: TYPE list_variables . pvg

    pvg  décalage et aller à l'état 36


état 23

    1 S: idf accol dt_div accol dec accor . pr_div accol list_inst accor accor

    pr_div  décalage et aller à l'état 37


état 24

    4 dec: dec_var dec .

    $défaut  réduction par utilisation de la règle 4 (dec)


état 25

    5 dec: dec_cst dec .

    $défaut  réduction par utilisation de la règle 5 (dec)


état 26

    6 dec: def_struc dec .

    $défaut  réduction par utilisation de la règle 6 (dec)


état 27

    7 dec: dec_struc dec .

    $défaut  réduction par utilisation de la règle 7 (dec)


état 28

   20 decst: idf . vrg decst
   21      | idf .

    vrg  décalage et aller à l'état 38

    $défaut  réduction par utilisation de la règle 21 (decst)


état 29

   19 dec_struc: STRUCT idf decst . pvg

    pvg  décalage et aller à l'état 39


état 30

   17 defst: TYPE . idf pvg
   18      | TYPE . idf pvg defst

    idf  décalage et aller à l'état 40


état 31

   16 def_struc: STRUCT accol defst . accor idf pvg

    accor  décalage et aller à l'état 41


état 32

   14 ent: idf egl . val

    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43

    val  aller à l'état 44


état 33

   13 dec_cst: CONST ent pvg .

    $défaut  réduction par utilisation de la règle 13 (dec_cst)


état 34

   12 list_variables: idf vrg . list_variables

    idf  décalage et aller à l'état 45

    list_variables  aller à l'état 46


état 35

   10 dec_var: TYPE idf baro . integer barf pvg

    integer  décalage et aller à l'état 47


état 36

    9 dec_var: TYPE list_variables pvg .

    $défaut  réduction par utilisation de la règle 9 (dec_var)


état 37

    1 S: idf accol dt_div accol dec accor pr_div . accol list_inst accor accor

    accol  décalage et aller à l'état 48


état 38

   20 decst: idf vrg . decst

    idf  décalage et aller à l'état 28

    decst  aller à l'état 49


état 39

   19 dec_struc: STRUCT idf decst pvg .

    $défaut  réduction par utilisation de la règle 19 (dec_struc)


état 40

   17 defst: TYPE idf . pvg
   18      | TYPE idf . pvg defst

    pvg  décalage et aller à l'état 50


état 41

   16 def_struc: STRUCT accol defst accor . idf pvg

    idf  décalage et aller à l'état 51


état 42

   51 val: integer .

    $défaut  réduction par utilisation de la règle 51 (val)


état 43

   50 val: flt .

    $défaut  réduction par utilisation de la règle 50 (val)


état 44

   14 ent: idf egl val .

    $défaut  réduction par utilisation de la règle 14 (ent)


état 45

   11 list_variables: idf .
   12               | idf . vrg list_variables

    vrg  décalage et aller à l'état 34

    $défaut  réduction par utilisation de la règle 11 (list_variables)


état 46

   12 list_variables: idf vrg list_variables .

    $défaut  réduction par utilisation de la règle 12 (list_variables)


état 47

   10 dec_var: TYPE idf baro integer . barf pvg

    barf  décalage et aller à l'état 52


état 48

    1 S: idf accol dt_div accol dec accor pr_div accol . list_inst accor accor

    IF     décalage et aller à l'état 53
    FOR    décalage et aller à l'état 54
    WHILE  décalage et aller à l'état 55
    idf    décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 23 (list_inst)

    list_inst        aller à l'état 57
    INST             aller à l'état 58
    Affectation      aller à l'état 59
    IF_STATEMENT     aller à l'état 60
    WHILE_STATEMENT  aller à l'état 61
    for_boucle       aller à l'état 62


état 49

   20 decst: idf vrg decst .

    $défaut  réduction par utilisation de la règle 20 (decst)


état 50

   17 defst: TYPE idf pvg .
   18      | TYPE idf pvg . defst

    INTEGER  décalage et aller à l'état 8
    FLOAT    décalage et aller à l'état 9

    $défaut  réduction par utilisation de la règle 17 (defst)

    TYPE   aller à l'état 30
    defst  aller à l'état 63


état 51

   16 def_struc: STRUCT accol defst accor idf . pvg

    pvg  décalage et aller à l'état 64


état 52

   10 dec_var: TYPE idf baro integer barf . pvg

    pvg  décalage et aller à l'état 65


état 53

   53 IF_STATEMENT: IF . Pouvr ExpCondition Pferm $@1 accol list_inst accor elsebloc

    Pouvr  décalage et aller à l'état 66


état 54

   57 for_boucle: FOR . Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor

    Pouvr  décalage et aller à l'état 67


état 55

   56 WHILE_STATEMENT: WHILE . Pouvr ExpCondition Pferm accol list_inst accor

    Pouvr  décalage et aller à l'état 68


état 56

   28 Affectation: idf . egl expressionArith pvg
   29            | idf . baro integer barf egl expressionArith pvg

    egl   décalage et aller à l'état 69
    baro  décalage et aller à l'état 70


état 57

    1 S: idf accol dt_div accol dec accor pr_div accol list_inst . accor accor

    accor  décalage et aller à l'état 71


état 58

   22 list_inst: INST . list_inst

    IF     décalage et aller à l'état 53
    FOR    décalage et aller à l'état 54
    WHILE  décalage et aller à l'état 55
    idf    décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 23 (list_inst)

    list_inst        aller à l'état 72
    INST             aller à l'état 58
    Affectation      aller à l'état 59
    IF_STATEMENT     aller à l'état 60
    WHILE_STATEMENT  aller à l'état 61
    for_boucle       aller à l'état 62


état 59

   25 INST: Affectation .

    $défaut  réduction par utilisation de la règle 25 (INST)


état 60

   24 INST: IF_STATEMENT .

    $défaut  réduction par utilisation de la règle 24 (INST)


état 61

   26 INST: WHILE_STATEMENT .

    $défaut  réduction par utilisation de la règle 26 (INST)


état 62

   27 INST: for_boucle .

    $défaut  réduction par utilisation de la règle 27 (INST)


état 63

   18 defst: TYPE idf pvg defst .

    $défaut  réduction par utilisation de la règle 18 (defst)


état 64

   16 def_struc: STRUCT accol defst accor idf pvg .

    $défaut  réduction par utilisation de la règle 16 (def_struc)


état 65

   10 dec_var: TYPE idf baro integer barf pvg .

    $défaut  réduction par utilisation de la règle 10 (dec_var)


état 66

   53 IF_STATEMENT: IF Pouvr . ExpCondition Pferm $@1 accol list_inst accor elsebloc

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    not      décalage et aller à l'état 74
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 76
    terme            aller à l'état 77
    facteur          aller à l'état 78
    ExpCondition     aller à l'état 79
    val              aller à l'état 80


état 67

   57 for_boucle: FOR Pouvr . idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor

    idf  décalage et aller à l'état 81


état 68

   56 WHILE_STATEMENT: WHILE Pouvr . ExpCondition Pferm accol list_inst accor

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    not      décalage et aller à l'état 74
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 76
    terme            aller à l'état 77
    facteur          aller à l'état 78
    ExpCondition     aller à l'état 82
    val              aller à l'état 80


état 69

   28 Affectation: idf egl . expressionArith pvg

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 83
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 70

   29 Affectation: idf baro . integer barf egl expressionArith pvg

    integer  décalage et aller à l'état 84


état 71

    1 S: idf accol dt_div accol dec accor pr_div accol list_inst accor . accor

    accor  décalage et aller à l'état 85


état 72

   22 list_inst: INST list_inst .

    $défaut  réduction par utilisation de la règle 22 (list_inst)


état 73

   36 facteur: idf . baro integer barf
   37        | idf .

    baro  décalage et aller à l'état 86

    $défaut  réduction par utilisation de la règle 37 (facteur)


état 74

   42 ExpCondition: not . ExpCondition

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    not      décalage et aller à l'état 74
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 76
    terme            aller à l'état 77
    facteur          aller à l'état 78
    ExpCondition     aller à l'état 87
    val              aller à l'état 80


état 75

   39 facteur: Pouvr . expressionArith Pferm

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 88
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 76

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   49 ExpCondition: expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 49 (ExpCondition)


état 77

   32 expressionArith: terme .
   33 terme: terme . times facteur
   34      | terme . divise facteur

    times   décalage et aller à l'état 91
    divise  décalage et aller à l'état 92

    $défaut  réduction par utilisation de la règle 32 (expressionArith)


état 78

   35 terme: facteur .

    $défaut  réduction par utilisation de la règle 35 (terme)


état 79

   40 ExpCondition: ExpCondition . or ExpCondition
   41             | ExpCondition . and ExpCondition
   43             | ExpCondition . G expressionArith
   44             | ExpCondition . L expressionArith
   45             | ExpCondition . EQ expressionArith
   46             | ExpCondition . GE expressionArith
   47             | ExpCondition . LE expressionArith
   48             | ExpCondition . DI expressionArith
   53 IF_STATEMENT: IF Pouvr ExpCondition . Pferm $@1 accol list_inst accor elsebloc

    G      décalage et aller à l'état 93
    L      décalage et aller à l'état 94
    EQ     décalage et aller à l'état 95
    GE     décalage et aller à l'état 96
    LE     décalage et aller à l'état 97
    DI     décalage et aller à l'état 98
    and    décalage et aller à l'état 99
    or     décalage et aller à l'état 100
    Pferm  décalage et aller à l'état 101


état 80

   38 facteur: val .

    $défaut  réduction par utilisation de la règle 38 (facteur)


état 81

   57 for_boucle: FOR Pouvr idf . Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor

    Dpoints  décalage et aller à l'état 102


état 82

   40 ExpCondition: ExpCondition . or ExpCondition
   41             | ExpCondition . and ExpCondition
   43             | ExpCondition . G expressionArith
   44             | ExpCondition . L expressionArith
   45             | ExpCondition . EQ expressionArith
   46             | ExpCondition . GE expressionArith
   47             | ExpCondition . LE expressionArith
   48             | ExpCondition . DI expressionArith
   56 WHILE_STATEMENT: WHILE Pouvr ExpCondition . Pferm accol list_inst accor

    G      décalage et aller à l'état 93
    L      décalage et aller à l'état 94
    EQ     décalage et aller à l'état 95
    GE     décalage et aller à l'état 96
    LE     décalage et aller à l'état 97
    DI     décalage et aller à l'état 98
    and    décalage et aller à l'état 99
    or     décalage et aller à l'état 100
    Pferm  décalage et aller à l'état 103


état 83

   28 Affectation: idf egl expressionArith . pvg
   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90
    pvg    décalage et aller à l'état 104


état 84

   29 Affectation: idf baro integer . barf egl expressionArith pvg

    barf  décalage et aller à l'état 105


état 85

    1 S: idf accol dt_div accol dec accor pr_div accol list_inst accor accor .

    $défaut  réduction par utilisation de la règle 1 (S)


état 86

   36 facteur: idf baro . integer barf

    integer  décalage et aller à l'état 106


état 87

   40 ExpCondition: ExpCondition . or ExpCondition
   41             | ExpCondition . and ExpCondition
   42             | not ExpCondition .
   43             | ExpCondition . G expressionArith
   44             | ExpCondition . L expressionArith
   45             | ExpCondition . EQ expressionArith
   46             | ExpCondition . GE expressionArith
   47             | ExpCondition . LE expressionArith
   48             | ExpCondition . DI expressionArith

    G   décalage et aller à l'état 93
    L   décalage et aller à l'état 94
    EQ  décalage et aller à l'état 95
    GE  décalage et aller à l'état 96
    LE  décalage et aller à l'état 97
    DI  décalage et aller à l'état 98

    $défaut  réduction par utilisation de la règle 42 (ExpCondition)


état 88

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   39 facteur: Pouvr expressionArith . Pferm

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90
    Pferm  décalage et aller à l'état 107


état 89

   31 expressionArith: expressionArith minus . terme

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    terme    aller à l'état 108
    facteur  aller à l'état 78
    val      aller à l'état 80


état 90

   30 expressionArith: expressionArith plus . terme

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    terme    aller à l'état 109
    facteur  aller à l'état 78
    val      aller à l'état 80


état 91

   33 terme: terme times . facteur

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    facteur  aller à l'état 110
    val      aller à l'état 80


état 92

   34 terme: terme divise . facteur

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    facteur  aller à l'état 111
    val      aller à l'état 80


état 93

   43 ExpCondition: ExpCondition G . expressionArith

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 112
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 94

   44 ExpCondition: ExpCondition L . expressionArith

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 113
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 95

   45 ExpCondition: ExpCondition EQ . expressionArith

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 114
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 96

   46 ExpCondition: ExpCondition GE . expressionArith

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 115
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 97

   47 ExpCondition: ExpCondition LE . expressionArith

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 116
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 98

   48 ExpCondition: ExpCondition DI . expressionArith

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 117
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 99

   41 ExpCondition: ExpCondition and . ExpCondition

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    not      décalage et aller à l'état 74
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 76
    terme            aller à l'état 77
    facteur          aller à l'état 78
    ExpCondition     aller à l'état 118
    val              aller à l'état 80


état 100

   40 ExpCondition: ExpCondition or . ExpCondition

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    not      décalage et aller à l'état 74
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 76
    terme            aller à l'état 77
    facteur          aller à l'état 78
    ExpCondition     aller à l'état 119
    val              aller à l'état 80


état 101

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm . $@1 accol list_inst accor elsebloc

    $défaut  réduction par utilisation de la règle 52 ($@1)

    $@1  aller à l'état 120


état 102

   57 for_boucle: FOR Pouvr idf Dpoints . expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 121
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 103

   56 WHILE_STATEMENT: WHILE Pouvr ExpCondition Pferm . accol list_inst accor

    accol  décalage et aller à l'état 122


état 104

   28 Affectation: idf egl expressionArith pvg .

    $défaut  réduction par utilisation de la règle 28 (Affectation)


état 105

   29 Affectation: idf baro integer barf . egl expressionArith pvg

    egl  décalage et aller à l'état 123


état 106

   36 facteur: idf baro integer . barf

    barf  décalage et aller à l'état 124


état 107

   39 facteur: Pouvr expressionArith Pferm .

    $défaut  réduction par utilisation de la règle 39 (facteur)


état 108

   31 expressionArith: expressionArith minus terme .
   33 terme: terme . times facteur
   34      | terme . divise facteur

    times   décalage et aller à l'état 91
    divise  décalage et aller à l'état 92

    $défaut  réduction par utilisation de la règle 31 (expressionArith)


état 109

   30 expressionArith: expressionArith plus terme .
   33 terme: terme . times facteur
   34      | terme . divise facteur

    times   décalage et aller à l'état 91
    divise  décalage et aller à l'état 92

    $défaut  réduction par utilisation de la règle 30 (expressionArith)


état 110

   33 terme: terme times facteur .

    $défaut  réduction par utilisation de la règle 33 (terme)


état 111

   34 terme: terme divise facteur .

    $défaut  réduction par utilisation de la règle 34 (terme)


état 112

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   43 ExpCondition: ExpCondition G expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 43 (ExpCondition)


état 113

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   44 ExpCondition: ExpCondition L expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 44 (ExpCondition)


état 114

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   45 ExpCondition: ExpCondition EQ expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 45 (ExpCondition)


état 115

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   46 ExpCondition: ExpCondition GE expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 46 (ExpCondition)


état 116

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   47 ExpCondition: ExpCondition LE expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 47 (ExpCondition)


état 117

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   48 ExpCondition: ExpCondition DI expressionArith .

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 48 (ExpCondition)


état 118

   40 ExpCondition: ExpCondition . or ExpCondition
   41             | ExpCondition . and ExpCondition
   41             | ExpCondition and ExpCondition .
   43             | ExpCondition . G expressionArith
   44             | ExpCondition . L expressionArith
   45             | ExpCondition . EQ expressionArith
   46             | ExpCondition . GE expressionArith
   47             | ExpCondition . LE expressionArith
   48             | ExpCondition . DI expressionArith

    G   décalage et aller à l'état 93
    L   décalage et aller à l'état 94
    EQ  décalage et aller à l'état 95
    GE  décalage et aller à l'état 96
    LE  décalage et aller à l'état 97
    DI  décalage et aller à l'état 98

    $défaut  réduction par utilisation de la règle 41 (ExpCondition)


état 119

   40 ExpCondition: ExpCondition . or ExpCondition
   40             | ExpCondition or ExpCondition .
   41             | ExpCondition . and ExpCondition
   43             | ExpCondition . G expressionArith
   44             | ExpCondition . L expressionArith
   45             | ExpCondition . EQ expressionArith
   46             | ExpCondition . GE expressionArith
   47             | ExpCondition . LE expressionArith
   48             | ExpCondition . DI expressionArith

    G   décalage et aller à l'état 93
    L   décalage et aller à l'état 94
    EQ  décalage et aller à l'état 95
    GE  décalage et aller à l'état 96
    LE  décalage et aller à l'état 97
    DI  décalage et aller à l'état 98

    $défaut  réduction par utilisation de la règle 40 (ExpCondition)


état 120

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm $@1 . accol list_inst accor elsebloc

    accol  décalage et aller à l'état 125


état 121

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   57 for_boucle: FOR Pouvr idf Dpoints expressionArith . Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor

    minus    décalage et aller à l'état 89
    plus     décalage et aller à l'état 90
    Dpoints  décalage et aller à l'état 126


état 122

   56 WHILE_STATEMENT: WHILE Pouvr ExpCondition Pferm accol . list_inst accor

    IF     décalage et aller à l'état 53
    FOR    décalage et aller à l'état 54
    WHILE  décalage et aller à l'état 55
    idf    décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 23 (list_inst)

    list_inst        aller à l'état 127
    INST             aller à l'état 58
    Affectation      aller à l'état 59
    IF_STATEMENT     aller à l'état 60
    WHILE_STATEMENT  aller à l'état 61
    for_boucle       aller à l'état 62


état 123

   29 Affectation: idf baro integer barf egl . expressionArith pvg

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 128
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 124

   36 facteur: idf baro integer barf .

    $défaut  réduction par utilisation de la règle 36 (facteur)


état 125

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm $@1 accol . list_inst accor elsebloc

    IF     décalage et aller à l'état 53
    FOR    décalage et aller à l'état 54
    WHILE  décalage et aller à l'état 55
    idf    décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 23 (list_inst)

    list_inst        aller à l'état 129
    INST             aller à l'état 58
    Affectation      aller à l'état 59
    IF_STATEMENT     aller à l'état 60
    WHILE_STATEMENT  aller à l'état 61
    for_boucle       aller à l'état 62


état 126

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints . expressionArith Dpoints ExpCondition Pferm accol list_inst accor

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 130
    terme            aller à l'état 77
    facteur          aller à l'état 78
    val              aller à l'état 80


état 127

   56 WHILE_STATEMENT: WHILE Pouvr ExpCondition Pferm accol list_inst . accor

    accor  décalage et aller à l'état 131


état 128

   29 Affectation: idf baro integer barf egl expressionArith . pvg
   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme

    minus  décalage et aller à l'état 89
    plus   décalage et aller à l'état 90
    pvg    décalage et aller à l'état 132


état 129

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm $@1 accol list_inst . accor elsebloc

    accor  décalage et aller à l'état 133


état 130

   30 expressionArith: expressionArith . plus terme
   31                | expressionArith . minus terme
   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith . Dpoints ExpCondition Pferm accol list_inst accor

    minus    décalage et aller à l'état 89
    plus     décalage et aller à l'état 90
    Dpoints  décalage et aller à l'état 134


état 131

   56 WHILE_STATEMENT: WHILE Pouvr ExpCondition Pferm accol list_inst accor .

    $défaut  réduction par utilisation de la règle 56 (WHILE_STATEMENT)


état 132

   29 Affectation: idf baro integer barf egl expressionArith pvg .

    $défaut  réduction par utilisation de la règle 29 (Affectation)


état 133

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm $@1 accol list_inst accor . elsebloc

    ELSE  décalage et aller à l'état 135

    elsebloc  aller à l'état 136


état 134

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints . ExpCondition Pferm accol list_inst accor

    idf      décalage et aller à l'état 73
    integer  décalage et aller à l'état 42
    flt      décalage et aller à l'état 43
    not      décalage et aller à l'état 74
    Pouvr    décalage et aller à l'état 75

    expressionArith  aller à l'état 76
    terme            aller à l'état 77
    facteur          aller à l'état 78
    ExpCondition     aller à l'état 137
    val              aller à l'état 80


état 135

   55 elsebloc: ELSE . accol $@2 list_inst accor

    accol  décalage et aller à l'état 138


état 136

   53 IF_STATEMENT: IF Pouvr ExpCondition Pferm $@1 accol list_inst accor elsebloc .

    $défaut  réduction par utilisation de la règle 53 (IF_STATEMENT)


état 137

   40 ExpCondition: ExpCondition . or ExpCondition
   41             | ExpCondition . and ExpCondition
   43             | ExpCondition . G expressionArith
   44             | ExpCondition . L expressionArith
   45             | ExpCondition . EQ expressionArith
   46             | ExpCondition . GE expressionArith
   47             | ExpCondition . LE expressionArith
   48             | ExpCondition . DI expressionArith
   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition . Pferm accol list_inst accor

    G      décalage et aller à l'état 93
    L      décalage et aller à l'état 94
    EQ     décalage et aller à l'état 95
    GE     décalage et aller à l'état 96
    LE     décalage et aller à l'état 97
    DI     décalage et aller à l'état 98
    and    décalage et aller à l'état 99
    or     décalage et aller à l'état 100
    Pferm  décalage et aller à l'état 139


état 138

   55 elsebloc: ELSE accol . $@2 list_inst accor

    $défaut  réduction par utilisation de la règle 54 ($@2)

    $@2  aller à l'état 140


état 139

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm . accol list_inst accor

    accol  décalage et aller à l'état 141


état 140

   55 elsebloc: ELSE accol $@2 . list_inst accor

    IF     décalage et aller à l'état 53
    FOR    décalage et aller à l'état 54
    WHILE  décalage et aller à l'état 55
    idf    décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 23 (list_inst)

    list_inst        aller à l'état 142
    INST             aller à l'état 58
    Affectation      aller à l'état 59
    IF_STATEMENT     aller à l'état 60
    WHILE_STATEMENT  aller à l'état 61
    for_boucle       aller à l'état 62


état 141

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol . list_inst accor

    IF     décalage et aller à l'état 53
    FOR    décalage et aller à l'état 54
    WHILE  décalage et aller à l'état 55
    idf    décalage et aller à l'état 56

    $défaut  réduction par utilisation de la règle 23 (list_inst)

    list_inst        aller à l'état 143
    INST             aller à l'état 58
    Affectation      aller à l'état 59
    IF_STATEMENT     aller à l'état 60
    WHILE_STATEMENT  aller à l'état 61
    for_boucle       aller à l'état 62


état 142

   55 elsebloc: ELSE accol $@2 list_inst . accor

    accor  décalage et aller à l'état 144


état 143

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst . accor

    accor  décalage et aller à l'état 145


état 144

   55 elsebloc: ELSE accol $@2 list_inst accor .

    $défaut  réduction par utilisation de la règle 55 (elsebloc)


état 145

   57 for_boucle: FOR Pouvr idf Dpoints expressionArith Dpoints expressionArith Dpoints ExpCondition Pferm accol list_inst accor .

    $défaut  réduction par utilisation de la règle 57 (for_boucle)
